README - An overview of the website’s model structure and file organization.
Project Title: Longhorn.done()


Introduction:
Below is a description of the project’s development procedure, where the methodology used to create the website will be explained. Additionally, the file structure will be discussed, which can be modified, added to, or altered in any other way to incorporate additional capabilities. The file structure is based on Django’s code structure, organized into a ‘Model Layer’, ‘View Layer’, and ‘Template Layer’.


Project Objective:
The project’s objective is to create a website using Django to host a project portfolio. The projects within the portfolio will be organized by various metadata to allow the website to filter based on associated courses, students, and professors. The website will also include several templates which will be able to display data in different arrangements. 


Methodology:
The beginning stages of the project involved setting up a simple functioning website. Django has a very helpful tutorial to get a website running quickly. From there, we needed to create our own database to populate the website with projects. 


The Model Layer:
The model layer defines the variables in the database. In the ‘models.py’ file, we defined classes each with their own attributes which Django used to create the database. We defined the following classes for our website: Course, Student, Professor, Tag, and Project. The classes are defined very similarly to how a class would be defined in a regular python script, however, we used Django’s built in data types for the attributes. We used CharField for a majority of the attributes, which just stores information as a string. We used ImageField for the storing of images, which are simply referenced by file name but must be stored in the ‘static’ folder. Finally, we used the ManyToManyField for defining the relationships between the classes. For example, a ManyToManyField was made for the professor class, which when populated, stores instances of the course class. Django automatically creates references so that the professor instances can also be accessed from the course class.

After telling Django how to store the data, we had to give it data to store. We created an excel spreadsheet for each class with columns as they were defined in the model layer. We manually created entries in the spreadsheets and exported the data as CSV’s. 

Django has a built in ipython shell where data can be added to the website. Inside the shell, instances of the model classes are defined in essentially the same manner as an instance in any python program. So in order to incorporate the data from our CSV files, we wrote simple programs using pandas to read the CSV file and create a class instance for every entry in the file.

Once the instance of a class is made, Django automatically updates the SQL file, ‘db.sqlite3’.  Although Django has support for many different database management systems, the standard python library has native support for SQLite, so Django uses it by default. This file contains the database and is automatically initialized by Django from the beginning of the website process. An important note is that in order to change the format of the SQL file, we had to make migrations to the file whenever we modified the ‘models.py’ file. Migrating the changes tasks Django with initializing the tables and columns that the SQL file uses.

After the data has been created and saved, the model layer is now complete, but any of the datasets can be accessed and edited at any time using the Django shell.


The View Layer & Template Layer:
In the view layer, the data to be displayed on the web page is retrieved from the database. The data is retrieved as instances of the classes defined in the models layer, so it retains the attributes of the class which can be accessed individually. The data is stored in a dictionary and input to Django’s built-in render function. 

The arguments of the render function are the dictionary of context as defined in the view layer, an HTML template defined in the template layer, and an HTTP request, which is automatically generated by the url to access the page. Each template is an HTML document which is parsed for brackets to indicate sections of python where the context variables are inserted. The render function then returns an HTTP response with the modified HTML to be displayed.


Template Details:
The template layer, referenced by both the model and view layer, has an HTML code base. The HTML code creates what is actually viewable on each of the website’s pages. In this project, five templates were created, which are able to display the information needed on all the pages we have created. 

The three main templates are named ‘linkedlist.html’, ‘tiled.html’, and ‘detailed.html’. The list template displays items in a list, with each item being a link. This is used for the professor, student, and course pages. The tiled template shows more information including images and tags in a list of larger boxes. This template is used to display projects in a course and projects completed by a student. The detailed template is the final template, which shows greater details about one specific project, including the title, description, tags, etc. Creating these templates in HTML required a bit of a learning curve, but through ample tinkering with examples pulled from internet sources, especially W3Schools, we were able to produce templates as we envisioned, with a large amount of the code original. 

While the three main templates are used for the majority of the pages on the website, we did make two separate templates, ‘home.html’ and ‘login.html’, for the home page and login page respectively. 

The home page template is very similar to the linked list template, but since the list and descriptions on the page are not populated by attributes of an object, we decided to make a separate template that instead references static data. We also took the opportunity to add in an image of our beautiful campus.

The login page template does not follow any of the templates so we had to generate a unique one. To be clear, we borrowed the login page html file nearly completely from an online tutorial, as we could not resist using the groot login page when we saw it. Additionally, we did not tap into the login and user features of Django and instead opted for a dummy version of a login page in order to focus on more important parts of the website. We did, however, write an html script function to only redirect users to the home page if they use the username ‘iamgroot’ and the password ‘programmingrocks’. While this functionality worked, there are obvious loopholes in security and the code would not be valid for creating multiple users.


Future Work:
There are a ton of features that could be added to a website like this. What we tried to do was focus on a couple examples of as many features as we could and perfect them. There are plenty of more pages or information on the projects that could be added, however, we were satisfied with the selection of content we had. Additionally, features that we did not explore but could be implemented for a more robust website include search capabilities, legitimate login security, and the ability for users to manage files and attributes on the site.  


Conclusions:
Overall, the website met our initial goals to create a dynamic website with a detailed database which can filter and display projects, courses, students, and professors. Our three main templates created a website which is adaptable to varying input data and can be easily expanded.